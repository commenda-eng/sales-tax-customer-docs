---
title: Future features
description: Planned features and enhancements for the Address API
---

This document outlines planned features and enhancements for the Address API.

## Effective date support for ISO 3166 content

### Overview

Add temporal validity to ISO 3166 subdivision data to handle historical changes in country subdivisions.

### Problem

Currently, the ISO 3166 content has a unique constraint on `(country_code, subdivision_code)`, which means:
- We can only store one version of each subdivision
- Historical changes (name changes, code changes, new subdivisions) overwrite previous data
- We cannot query what a subdivision was called at a specific point in time

### Proposed solution

Add `effective_start_date` and `effective_end_date` columns to track when each subdivision record is valid.

#### Database schema changes

```sql
ALTER TABLE iso_3166
ADD COLUMN effective_start_date DATE NOT NULL DEFAULT '1900-01-01',
ADD COLUMN effective_end_date DATE NULL;

-- Drop old unique constraint
ALTER TABLE iso_3166
DROP CONSTRAINT iso_3166_country_subdivision_unique;

-- Add new unique constraint with date range
ALTER TABLE iso_3166
ADD CONSTRAINT iso_3166_country_subdivision_date_unique
  EXCLUDE USING gist (
    country_code WITH =,
    subdivision_code WITH =,
    daterange(effective_start_date, effective_end_date, '[]') WITH &&
  );
```

#### Updated ingestion API

The ingestion endpoint would accept effective dates:

```json
{
  \"items\": [
    {
      \"country_code\": \"US\",
      \"subdivision_code\": \"CA\",
      \"subdivision_name\": \"California\",
      \"subdivision_local_variant\": null,
      \"effective_start_date\": \"1850-09-09\",
      \"effective_end_date\": null
    }
  ]
}
```

#### Query logic

When geocoding an address, the API would:

1. Use the current date by default
2. Query for the subdivision that was valid on that date:
   ```sql
   SELECT * FROM iso_3166
   WHERE country_code = $1
     AND subdivision_code = $2
     AND effective_start_date <= CURRENT_DATE
     AND (effective_end_date IS NULL OR effective_end_date >= CURRENT_DATE)
   LIMIT 1;
   ```

### Benefits

- **Historical accuracy**: Correctly handle addresses from different time periods
- **Audit trail**: Track when subdivision names or codes changed
- **Data integrity**: Prevent accidental overwrites of historical data
- **Compliance**: Meet regulatory requirements for historical address validation

### Implementation steps

1. **Create migration**:
   ```bash
   atlas migrate diff add_effective_dates \
     --dir \"file://database/migrations\" \
     --dev-url \"docker://postgres/15/dev?search_path=public\" \
     --to \"file://database/schema.sql\"
   ```

2. **Update database schema** (`database/schema.sql`):
   - Add `effective_start_date` and `effective_end_date` columns
   - Update unique constraint to include date range

3. **Update SQL queries** (`internal/content_ingestion/sql/queries.sql`):
   - Modify upsert logic to handle date ranges
   - Add query to find subdivision by date

4. **Update DTOs**:
   - Add date fields to `ISO3166IngestItem`
   - Add validation for date ranges

5. **Update ingestion handler**:
   - Validate date ranges (start < end)
   - Check for overlapping date ranges
   - Handle null end dates (current/ongoing)

6. **Update geocoding logic**:
   - Query by current date
   - Handle cases where no valid subdivision exists for the date

7. **Add tests**:
   - Test date range validation
   - Test overlapping date ranges
   - Test historical queries
   - Test current date queries

8. **Update documentation**:
   - Document new ingestion API fields
   - Explain date range behavior
   - Provide examples of historical data

### Example use cases

#### 1. Subdivision name change

**Scenario**: A state changes its official name

```json
[
  {
    \"country_code\": \"IN\",
    \"subdivision_code\": \"OR\",
    \"subdivision_name\": \"Orissa\",
    \"effective_start_date\": \"1950-01-26\",
    \"effective_end_date\": \"2011-11-01\"
  },
  {
    \"country_code\": \"IN\",
    \"subdivision_code\": \"OR\",
    \"subdivision_name\": \"Odisha\",
    \"effective_start_date\": \"2011-11-01\",
    \"effective_end_date\": null
  }
]
```

#### 2. New subdivision created

**Scenario**: A new state is created from an existing state

```json
[
  {
    \"country_code\": \"IN\",
    \"subdivision_code\": \"TG\",
    \"subdivision_name\": \"Telangana\",
    \"effective_start_date\": \"2014-06-02\",
    \"effective_end_date\": null
  }
]
```

#### 3. Subdivision code change

**Scenario**: A subdivision changes its ISO code

```json
[
  {
    \"country_code\": \"XX\",
    \"subdivision_code\": \"OLD\",
    \"subdivision_name\": \"Old Name\",
    \"effective_start_date\": \"2000-01-01\",
    \"effective_end_date\": \"2020-12-31\"
  },
  {
    \"country_code\": \"XX\",
    \"subdivision_code\": \"NEW\",
    \"subdivision_name\": \"Old Name\",
    \"effective_start_date\": \"2021-01-01\",
    \"effective_end_date\": null
  }
]
```

### Considerations

#### Performance

- **Index on date columns**: Add indexes to optimize date range queries
- **Materialized view**: Consider a materialized view for current subdivisions
- **Caching**: Cache current subdivisions separately from historical ones

#### Data migration

- **Existing data**: Set `effective_start_date` to a default historical date (e.g., `1900-01-01`)
- **End dates**: Set `effective_end_date` to `NULL` for all current subdivisions
- **Validation**: Ensure no overlapping date ranges exist

#### API compatibility

- **Backward compatibility**: Make date fields optional in ingestion API
- **Default behavior**: Use current date if no date specified
- **Versioning**: Consider API versioning if breaking changes needed

### Timeline

- **Phase 1**: Database schema changes and migration (1 week)
- **Phase 2**: Update ingestion API and logic (1 week)
- **Phase 3**: Update geocoding logic (1 week)
- **Phase 4**: Testing and documentation (1 week)
- **Phase 5**: Deployment and monitoring (1 week)

**Total estimated time**: 5 weeks

## Other potential features

### 1. Batch geocoding

**Description**: Allow geocoding multiple addresses in a single request

**Benefits**:
- Reduce API calls
- Improve performance for bulk operations
- Better rate limit management

### 2. Reverse geocoding

**Description**: Convert coordinates to addresses

**Benefits**:
- Support location-based services
- Complement forward geocoding

### 3. Address autocomplete

**Description**: Provide address suggestions as users type

**Benefits**:
- Improve user experience
- Reduce geocoding errors
- Increase cache hit rate

### 4. Custom geocoding providers

**Description**: Support multiple geocoding providers (not just Google)

**Benefits**:
- Reduce vendor lock-in
- Improve reliability (fallback providers)
- Optimize costs

### 5. Address validation

**Description**: Validate address format without geocoding

**Benefits**:
- Faster validation
- Lower costs
- Better error messages

## Contributing

If you'd like to contribute to any of these features, please:

1. Open a GitHub issue to discuss the feature
2. Review the implementation plan
3. Submit a pull request with your changes
4. Update documentation

## Next steps

- [Contributing guide](/engine/address-api/development/contributing)
- [Infrastructure](/engine/address-api/infrastructure)
