---
title: GitHub workflows
description: CI/CD workflows and automated checks
---

The Address API uses GitHub Actions for continuous integration and deployment. This guide explains all workflows and checks.

## Workflow overview

| Workflow | Trigger | Purpose |
|----------|---------|---------|
| PR Checks | Pull request | Run linting, formatting, tests |
| Deploy Staging | Pre-release tag | Deploy to staging environment |
| Deploy Production | Release tag | Deploy to production environment |

## PR checks workflow

**File**: `.github/workflows/pr-checks.yml`

**Triggers**: Pull request to `main` branch

### Jobs

#### 1. Go Lint

**Purpose**: Ensure code quality and catch common issues

**Tool**: `golangci-lint`

**What it checks**:
- Unused variables and imports
- Code complexity
- Error handling
- Code style violations
- Security issues

**Command**:
```bash
golangci-lint run --timeout=5m
```

**Common failures**:
- Unused imports
- Inefficient code patterns
- Missing error checks

#### 2. Go Format

**Purpose**: Ensure consistent code formatting

**Tool**: `goimports`

**What it checks**:
- Code formatting (tabs vs spaces, line breaks)
- Import organization
- Import grouping (stdlib, external, internal)

**Command**:
```bash
goimports -w -local github.com/commenda/addresses-api .
```

**Common failures**:
- Incorrect indentation
- Unorganized imports
- Missing local import prefix

#### 3. Check Build

**Purpose**: Verify code compiles successfully

**Command**:
```bash
go build $(go list ./... | grep -v /tests/)
```

**Common failures**:
- Syntax errors
- Missing dependencies
- Type mismatches

#### 4. Sqlc Lint

**Purpose**: Validate SQL queries and generated code

**Tool**: `sqlc`

**What it checks**:
- SQL syntax
- Query parameter types
- Return type consistency
- Schema compatibility

**Command**:
```bash
sqlc vet
```

**Common failures**:
- Invalid SQL syntax
- Mismatched parameter types
- Schema drift

#### 5. Migrations Lint

**Purpose**: Ensure database schema and migrations are in sync

**Tool**: `atlas`

**What it checks**:
- Schema changes have corresponding migrations
- Migration files are valid SQL
- No schema drift

**Command**:
```bash
atlas migrate diff SOMEONE_FORGOT_TO_CREATE_A_MIGRATION \
  --dir file://database/migrations \
  --dev-url docker://postgres/15/dev?search_path=public \
  --to file://database/schema.sql
```

**Common failures**:
- Modified `database/schema.sql` without creating migration
- Invalid migration SQL
- Migration conflicts

#### 6. Integration Tests

**Purpose**: Run full integration test suite

**Tool**: `go test` with testcontainers

**What it tests**:
- API endpoints
- Database operations
- Authentication and authorization
- Geocoding functionality
- Content ingestion

**Command**:
```bash
go test -v -timeout 2m ./tests/integration/...
```

**Environment**:
- Uses testcontainers to spin up PostgreSQL
- Requires `GOOGLE_GEOCODING_API_KEY` secret

**Common failures**:
- Test assertions fail
- Database connection issues
- Google API key missing or invalid

## Deployment workflows

### Staging deployment

**File**: `.github/workflows/deploy-staging.yml`

**Trigger**: Pre-release tag (e.g., `v0.1.0-rc.1`)

**Steps**:

1. **Checkout code**
   ```yaml
   - uses: actions/checkout@v4
   ```

2. **Configure AWS credentials**
   ```yaml
   - uses: aws-actions/configure-aws-credentials@v4
     with:
       aws-region: ap-south-1
       role-to-assume: arn:aws:iam::127214192604:role/github-actions
   ```

3. **Login to ECR**
   ```yaml
   - name: Login to Amazon ECR
     run: aws ecr get-login-password | docker login --username AWS --password-stdin $ECR_REGISTRY
   ```

4. **Build Docker image**
   ```yaml
   - name: Build image
     run: docker build -t address-api:${{ github.ref_name }} .
   ```

5. **Push to ECR**
   ```yaml
   - name: Push image
     run: |
       docker tag address-api:${{ github.ref_name }} $ECR_REGISTRY/address-api:${{ github.ref_name }}
       docker push $ECR_REGISTRY/address-api:${{ github.ref_name }}
   ```

6. **Update ECS task definition**
   ```yaml
   - name: Update task definition
     run: |
       aws ecs register-task-definition \
         --family address-api \
         --container-definitions file://task-definition.json
   ```

7. **Deploy to ECS**
   ```yaml
   - name: Deploy to ECS
     run: |
       aws ecs update-service \
         --cluster staging-ecs-cluster \
         --service address-api \
         --task-definition address-api:$REVISION \
         --force-new-deployment
   ```

8. **Wait for deployment**
   ```yaml
   - name: Wait for service stability
     run: |
       aws ecs wait services-stable \
         --cluster staging-ecs-cluster \
         --services address-api
   ```

### Production deployment

**File**: `.github/workflows/deploy-prod.yml`

**Trigger**: Release tag (e.g., `v0.1.0`)

**Steps**: Same as staging deployment, but targets production AWS account (429032495558)

**Differences**:
- Uses production AWS credentials
- Deploys to `prod-ecs-cluster`
- Uses production ECR registry
- Requires manual approval (optional)

## Workflow secrets

The following secrets are configured in GitHub:

| Secret | Purpose | Used in |
|--------|---------|---------|
| `GOOGLE_GEOCODING_API_KEY` | Google API key for tests | PR Checks |
| `AWS_ROLE_ARN_STAGING` | AWS IAM role for staging | Deploy Staging |
| `AWS_ROLE_ARN_PROD` | AWS IAM role for production | Deploy Production |

## Workflow permissions

The workflows use OIDC to authenticate with AWS:

```yaml
permissions:
  id-token: write
  contents: read
```

This allows GitHub Actions to assume AWS IAM roles without storing long-lived credentials.

## Monitoring workflows

### View workflow runs

1. Go to [GitHub Actions](https://github.com/commenda-eng/address-api/actions)
2. Select a workflow
3. View run history and logs

### Workflow status badges

Add status badges to README:

```markdown
![PR Checks](https://github.com/commenda-eng/address-api/actions/workflows/pr-checks.yml/badge.svg)
![Deploy Staging](https://github.com/commenda-eng/address-api/actions/workflows/deploy-staging.yml/badge.svg)
```

## Troubleshooting workflows

### PR checks fail

**Go Lint fails**:
```bash
# Run locally
golangci-lint run --timeout=5m

# Fix issues
golangci-lint run --fix
```

**Go Format fails**:
```bash
# Run locally
goimports -w -local github.com/commenda/addresses-api .

# Commit changes
git add .
git commit -m \"fix: format code\"
```

**Migrations Lint fails**:
```bash
# Create missing migration
atlas migrate diff your_change_description \
  --dir \"file://database/migrations\" \
  --dev-url \"docker://postgres/15/dev?search_path=public\" \
  --to \"file://database/schema.sql\"

# Commit migration
git add database/migrations/
git commit -m \"feat: add migration for schema changes\"
```

**Integration Tests fail**:
```bash
# Run locally
go test -v ./tests/integration/...

# Debug specific test
go test -v -run TestGeocodeEndpoint ./tests/integration/...
```

### Deployment fails

**ECR push fails**:
- Check AWS credentials
- Verify ECR repository exists
- Ensure IAM role has ECR permissions

**ECS deployment fails**:
- Check task definition is valid
- Verify ECS cluster and service exist
- Review CloudWatch logs for task failures

**Service doesn't stabilize**:
- Check health check configuration
- Verify ALB target group health
- Review application logs

## Best practices

### For contributors

- **Run checks locally** before pushing
- **Fix linting issues** immediately
- **Write tests** for new features
- **Keep PRs small** for faster reviews

### For maintainers

- **Monitor workflow runs** regularly
- **Update dependencies** in workflows
- **Review failed workflows** promptly
- **Keep secrets up to date**

## Next steps

- [Contributing guide](/engine/address-api/development/contributing)
- [Deployment process](/engine/address-api/operations/deployment)
